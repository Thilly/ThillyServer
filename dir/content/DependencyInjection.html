<div class="faq">

<h2>Something neat along the way: 5 June 2014</h2>
<p>So when I first included my logging for my server that can be set with all kinds of flags. So I can track down errors and strange lil behaviors that I dont want to complicate things later it was a non issue. Create one big logging object then check the different flags before logging or what not, looks like this:

<pre>
sockets.on('connection', function(socket){
	if(logging.trace)
		logging.log('In sockets.on("connection")');
	if(logging.sockets)
		logging.log(socket.id + ' connected');
	...
</pre>

<p>A really simple example above, nothing too crazy there. When the socket connects, if I currently care about seeing what the server is doing at the moment, log the trace, if I care to see what sockets are up to, log the socket action, simple. It got weird when I wanted to add logging to my file module. No big deal right? Kinda, my logging object writes to a file, so it uses the file module, which uses the logging module, which uses the file... you see where this is going.

<p>Node DOES recognize the circular dependency there, before I did mind you, kinda ashamed about that. So instead of something like a stack overflow from the recursive requires it just bails and tells me it can't find one of them, usually the first one 'required' in the main program. So to get around this, I create a module that is just a constructor for the business that I want out of it. The first one passes itself into the module and then the second module uses the first one to fill the requirement it needed from that module.

<pre>

//how the 'second' module gets the 'first' module
//from inside of the first module ('thillyLogging')
var files = require('./thillyFiles.js');
	files = new files(this);
//that's half of what's needed to break the circular dependency in this file
	
	
//inside of the 'second' module
module.exports = function(logObject)
{//dependency injected from thillyLogging to prevent circular dependency

	logging = logObject;

	return{
		'fileHandler'	:	fileHandler,
		'readFile'		:	readFile,
		'writeFile'		:	writeFile,
		'appendFile'	:	appendFile,
		'appendLog'		:	appendLog
	};
};//end of module.export
</pre>

<p>So what happens here is the first call to require'(./thillyFiles.js') gets just the constructor function, while that module is loaded with the actual code. Then I generate a new one of those using 'this' (the logging module) and then I have a full usable fileI/O library. It's pretty cool, I may be explaining it terribly but it does really make sense and is pretty damn useful for constricting namespaces, dynamic modules and what not, yadda yadda. I don't think this will be the last time this lil' technique shows up. Hopefully it's not just bad form. It feels good to me, especially since I cant really create a third module to break the dependency in this example. 'til next time :D

<div>